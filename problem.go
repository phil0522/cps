package cps

import (
	"fmt"
	"strings"
)

// Problem defines a constraint puzzle, variable and domain may be added later.
// A constraint problem can be defined by set of variable and their domains.
type Problem struct {
	domains     Domains
	variables   Variables
	constraints []Constraint
	context     []varContext
	solutions   []Solution
}

// AddStringVariables adds distinct string varaible to the problem
// size of input must match domains of the problem.
func (p *Problem) AddStringVariables(kind string, names ...string) {
	if len(names) != len(p.domains) {
		panic("variables length must match size of domains")
	}
	for _, name := range names {
		p.variables.Add(name)
	}

	// Add additional not_equal variables
	for i := 0; i < len(names); i++ {
		for j := i + 1; j < len(names); j++ {
			desc := fmt.Sprintf("not-equal %s-%s-%s", kind, names[i], names[j])
			p.AddConstraintRule(desc, NotEqual(names[i], names[j]), names[i], names[j])
		}
	}
}

// NotEqual returns a func that asserts v1 and v2 can not be equal
func NotEqual(v1, v2 string) func(vs *Variables) bool {
	return func(vs *Variables) bool {
		return vs.Of(v1) != vs.Of(v2)
	}
}

// AddIntegerVariables adds distinct integer values.
// Name of variables is auto generated by concatnate kind and values
func (p *Problem) AddIntegerVariables(kind string, values ...int) {
	if len(values) != len(p.domains) {
		panic("variables length must match size of domains")
	}
	for _, v := range values {
		name := fmt.Sprintf("%s*%d", kind, v)
		p.variables.Add(name)
	}

	// Add additional not_equal variables
	for i := 0; i < len(values); i++ {
		name1 := fmt.Sprintf("%s*%d", kind, values[i])
		for j := i + 1; j < len(values); j++ {
			name2 := fmt.Sprintf("%s*%d", kind, values[j])
			desc := fmt.Sprintf("not-equal %s-%d-%d", kind, values[i], values[j])

			p.AddConstraintRule(desc, NotEqual(name1, name2), name1, name2)
		}
	}
}

// AddConstraintRule adds a new constraint. names are impacted variables used in
// this constraint. "*" means all, "age*" means all integer-value varaibles whose
// variable name starts with "age*", others are exact match.
func (p *Problem) AddConstraintRule(desc string, rule Rule, names ...string) {
	constraint := MakeContraint(desc)
	constraint.rule = rule
	for _, name := range names {
		if strings.HasSuffix(name, "*") {
			for vname := range p.variables.items {
				if strings.HasPrefix(vname, name) {
					constraint.nameSet[vname] = true
				}
			}
		} else {
			_, ok := p.variables.items[name]
			if !ok {
				panic(fmt.Sprintf("variable does not exist[%s]", name))
			}
			constraint.nameSet[name] = true
		}
	}
	p.constraints = append(p.constraints, constraint)
}

// Constraints returns contraints
func (p *Problem) Constraints() []Constraint {
	return p.constraints
}

// PrintSolutions prints out all solutions
func (p *Problem) PrintSolutions() {
	for _, s := range p.solutions {
		OutputSolution(s)
	}
}
